import os
import sys
import glob
import shutil
from subprocess import Popen, PIPE

from Config import Config
from Listfile import Listfile
from Chunk import Chunk

# Do not close console after error
def exc_handler(exc_type, exc_value, tb):
    import traceback
    traceback.print_exception(exc_type, exc_value, tb)
    input("Press Enter to exit.")
    sys.exit(-1)
sys.excepthook = exc_handler

config = Config('./config.txt')

input_path = os.path.abspath(config.get('input', './input/')) + '/'
output_path = os.path.abspath(config.get('output', './output/')) + '/'

script_folder = os.path.dirname(sys.argv[0])

#   Clearing the output folder

if config.get('clear_output_dir'):
    for path in glob.glob(f'{output_path}*'):
        os.remove(path)

#   Removing bad chunks
#   This chunks causes troubles when you try convert cata adt (CATA -> 335 -> SL) or something

bad_chunks = [Chunk.MCLV, Chunk.MCMT]
for path in glob.glob(input_path + '*.adt'):
    with open(path, 'rb+') as file:
        data = file.read()
        for bad_chunk in bad_chunks:
            chunk_name = bad_chunk.decode('UTF-8').lower()[::-1] # Get chunk name as string and reverse it
            if not config.get('remove_' + chunk_name, True):
                continue
            pos = 0
            while (pos := data.find(bad_chunk, pos+4)) != -1:
                file.seek(pos)
                file.write(b'\0\0\0\0')

#   Convert ADT from 3.3.5 to 6.x.x
#   Tool author: Luzifix
#   https://github.com/Luzifix/ADTConvert

print('Converting adt...')
os.system(f'"{script_folder}/tools/ADTConvert.exe {input_path} -o={output_path} -noUpdate -s"')

#   Deleting trash files
#   These files generated by the converter do not work on SL version (but maybe u can fix this?)
#   Usually these files are not needed for the minimal work of those replaced via cast host adt

if path := glob.glob(f'{output_path}*.tex'):
    path = path[0].replace('.tex', '')
    for ext in ['.tex', '.wdl', '.wdt', '_lgt.wdt']:
        if os.path.exists(path + ext):
            os.remove(path + ext)

#   Swapping texture path to file id
#   MTEX -> MDID, Mh_id

print('Loading listfile...')
listfile = Listfile(config.get('listfile', './listfile.csv'))
print('Listfile success loaded')

taken_textures = []
def getAnyFreeTextureId() -> int:
    '''
    Used for situations when noggit created empty textures like "error_1.blp"
    '''
    for id, fname in listfile._data.items():
        if fname.startswith('tileset/'):
            specular_id = id
            if fname.find('_s.blp') == -1:
                specular_id = listfile.getId(fname.replace('.blp', '_s.blp'))
                if not specular_id:
                    continue
            if not (specular_id in taken_textures):
                taken_textures.append(specular_id)
                print('Replaced to random free texture')
                return specular_id
    return 0

print('Fixing textures...')

for path in glob.glob(f'{output_path}*_tex0.adt'):
    with open(path, 'rb+') as file:
        # MTEX
        # https://wowdev.wiki/ADT/v18#MTEX_chunk
        mtex = file.read().find(Chunk.MTEX)
        if mtex != -1:
            start = mtex
            mtex += 4 # Skip chunk name
            file.seek(mtex)
            length = int.from_bytes(file.read(4), byteorder='little')

            textures = file.read(length).decode('ascii').split('\x00')
            end = file.tell() # MTEX block end
            s_textures = []
            h_textures = []
            for texture in textures:
                pos = texture.find('.blp')
                if pos != -1:
                    _s = texture[:pos] + '_s' + texture[-4:]
                    _h = texture[:pos] + '_h' + texture[-4:]
                    # Specular texture (_s.blp)
                    if s_id := listfile.getId(_s):
                        s_textures.append(int(s_id))
                        taken_textures.append(int(s_id))
                    else:
                        print('Texture not found in listfile:\n' + _s)
                        s_textures.append(int(getAnyFreeTextureId()))
                        continue

                    # Height texture
                    h_id = listfile.getId(_h) or 0
                    h_textures.append(int(h_id))

            # MDID
            # https://wowdev.wiki/ADT/v18#MDID
            file.seek(start)
            file.write(Chunk.MDID)
            
            textures_amount = int.to_bytes(len(s_textures)*4, 4, 'little')
            file.write(textures_amount)
            for id in s_textures:
                file.write(int.to_bytes(id, 4, 'little'))
            
            # MHID
            # https://wowdev.wiki/ADT/v18#MHID
            file.write(Chunk.MHID)
            file.write(textures_amount)
            for id in h_textures:
                if id == 0:
                    file.write(bytes(bytearray(4)))
                else:
                    file.write(int.to_bytes(id, 4, 'little'))

            # Cutting out an extra piece of data
            start = file.tell()
            file.seek(0)
            b = file.read()
            b = b[:start] + b[end:]
            file.seek(0)
            file.write(b)
            file.truncate()
            
    # Copying tex0 to tex1
    path2 = path.replace('_tex0.adt', '_tex1.adt')
    if os.path.exists(path2):
        os.remove(path2)
    shutil.copyfile(path, path2)

print('Textures fixed')

#   Fix obj files
#   Tool author: Varen
#   https://github.com/Varen/WoW-ObjX.adt-Optimizer_735

print('Fixing OBJ files...')

optimizer_folder = script_folder + '/tools/optimizer'

#   Adding missing models to BoundingBoxData.dat file
dat = []
with open(optimizer_folder + '/BoundingBoxData.dat', 'rb') as file:
    while True:
        length = file.read(1)
        if not length:
            break
        length = int.from_bytes(length, byteorder='little')
        
        model = file.read(length).decode('ascii')
        dat.append(model.lower())
        
        file.read(24) # Skip float X Y Z X Y Z - bounding box

map = []
for path in glob.glob(input_path + '*.adt'):
    with open(path, 'rb+') as file:
        mmdx = file.read().find(Chunk.MMDX)
        mmdx += 4 # Skip chunk name
        file.seek(mmdx)

        length = int.from_bytes(file.read(4), byteorder='little') # Chunk len

        models = file.read(length).decode("ascii").split('\x00')
        for model in models:
            if model == "":
                continue
            model = model.lower().replace("\\", "/")
            if not (model in map):
                map.append(model)

lost_models = []
for model in map:
    if not (model in dat):
        lost_models.append(model)

if len(lost_models) > 0:
    with open(optimizer_folder + '/BoundingBoxData.dat', 'ab') as file:
        for model in lost_models:
            file.write(int.to_bytes(len(model), 1, 'little'))
            file.write(bytes(model, 'ascii'))
            # Fake bounding box: float X Y Z X Y Z
            file.write(bytearray([0x42, 0x9E, 0x2F, 0xC2,  0x72, 0xF1, 0xAB, 0xC1,  0x57, 0xEB, 0xA9, 0xC0,  0xAA, 0x3F, 0x09, 0x41,  0x50, 0x98, 0xAC, 0x41,  0x3A, 0x03, 0x3D, 0x42]))

#   Converting obj files
if obj_files := glob.glob(output_path + '*_obj*.adt'):
    for obj_file in obj_files:
        shutil.copyfile(obj_file, './tools/optimizer/Input/' + os.path.basename(obj_file))
    
    os.chdir(optimizer_folder)
    p = Popen([f'{optimizer_folder}/Obj_Optimizer_7x.exe'], stdin=PIPE, shell=True)
    p.communicate(input=b'\n') # skip "...All Done!"

    if converted_obj := glob.glob(optimizer_folder + '/Output/*'):
        for obj in converted_obj:
            shutil.copyfile(obj, output_path + '/' + os.path.basename(obj))
            os.remove(obj)
            os.remove(optimizer_folder + '/Input/' + os.path.basename(obj))